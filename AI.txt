What are the differences between Mandela fractals and Newtonian fractals
ChatGPT said:
Good question — they’re both iterative fractals, but they come from very different mathematical ideas. Let me break it down clearly:
1. Generating Functions
Mandelbrot fractals (and Julia sets):
Based on iteration of a complex quadratic map (or general polynomials):
z
n
+
1
=
z
n
2
+
c
z 
n+1
​	
 =z 
n
2
​	
 +c
where 
c
c is a complex parameter.
The fractal structure comes from asking: Does the orbit of 
z
0
z 
0
​	
 remain bounded or diverge?
Newton fractals:
Based on Newton’s root-finding method in the complex plane:
z
n
+
1
=
z
n
−
f
(
z
n
)
f
′
(
z
n
)
z 
n+1
​	
 =z 
n
​	
 − 
f 
′
 (z 
n
​	
 )
f(z 
n
​	
 )
​	
 
Instead of bounded vs. unbounded, you color points by which root of 
f
(
z
)
f(z) the iteration converges to, or mark divergence if it fails.
2. Behavior
Mandelbrot/Julia:
They encode the boundary between stable and unstable orbits.
Fractal structure is tied to chaotic divergence on the boundary.
Coloring is often based on escape time (how quickly a point diverges).
Newton fractals:
They encode the basins of attraction of different roots.
Fractal structure comes from the boundary between different basins.
Coloring is based on which root a starting point converges to (and sometimes the speed of convergence).
3. Geometry
Mandelbrot/Julia:
Shapes often have self-similar dendritic structures, spirals, and filaments.
Mandelbrot set itself is “the set of all c-values where the iteration doesn’t diverge.”
Julia sets can look connected (like filigree) or dust-like depending on 
c
c.
Newton fractals:
Characterized by regions of attraction (large colored blobs) separated by extremely intricate fractal boundaries.
Often have a “tie-dye” or “shattered glass” look.
4. Underlying Idea
Mandelbrot/Julia:
→ About stability of dynamical systems in complex iteration.
Newton fractals:
→ About root-finding dynamics and basins of attraction.
✅ In short:
Mandelbrot fractals are about bounded vs. divergent orbits in polynomial iteration.
Newton fractals are about which root Newton’s method converges to (different colors) and the fractal boundaries between these basins.
Do you want me to make a side-by-side visual comparison (Mandelbrot vs Newton) using Python so you can see the difference?
You said:
What are the differences in terms of code
ChatGPT said:
Great angle 👌 — the math differences between Mandelbrot/Julia fractals and Newton fractals translate directly into different iteration code. Let me show you a side-by-side coding comparison.
1. Mandelbrot Set (divergence test)
Here we test whether the orbit of 
z
n
+
1
=
z
n
2
+
c
z 
n+1
​	
 =z 
n
2
​	
 +c diverges.
import numpy as np
import matplotlib.pyplot as plt

# Grid in the complex plane
X, Y = np.meshgrid(np.linspace(-2, 1, 1000), np.linspace(-1.3, 1.3, 1000))
C = X + 1j*Y
Z = np.zeros_like(C)
divergence_steps = np.zeros(C.shape, dtype=int)

max_iter = 200

for i in range(max_iter):
    Z = Z**2 + C
    mask = (np.abs(Z) > 2) & (divergence_steps == 0)
    divergence_steps[mask] = i

plt.imshow(divergence_steps, cmap="magma", extent=(-2,1,-1.3,1.3))
plt.title("Mandelbrot Set")
plt.show()
🔹 Logic:
Iterate 
z
=
z
2
+
c
z=z 
2
 +c.
Check if 
∣
z
∣
>
2
∣z∣>2 → divergence.
Color by escape time (iteration when it diverged).
2. Newton Fractal (basins of attraction)
Here we iterate Newton’s method:
z
n
+
1
=
z
n
−
f
(
z
)
f
′
(
z
)
z 
n+1
​	
 =z 
n
​	
 − 
f 
′
 (z)
f(z)
​	
 
and color by which root it converges to.
# Example function: f(z) = z^3 - 1 (roots at cube roots of unity)
def f(z): return z**3 - 1
def f_prime(z): return 3*z**2

# Grid in complex plane
X, Y = np.meshgrid(np.linspace(-1.5, 1.5, 1000), np.linspace(-1.5, 1.5, 1000))
Z = X + 1j*Y

max_iter = 40
tol = 1e-6

for i in range(max_iter):
    Z = Z - f(Z)/f_prime(Z)

# Identify which root each point converged to
roots = np.array([1, -0.5 + 0.866j, -0.5 - 0.866j])
root_index = np.zeros(Z.shape, dtype=int)

for i, r in enumerate(roots):
    mask = np.abs(Z - r) < tol
    root_index[mask] = i+1

plt.imshow(root_index, cmap="Accent", extent=(-1.5,1.5,-1.5,1.5))
plt.title("Newton Fractal for f(z) = z^3 - 1")
plt.show()
🔹 Logic:
Iterate Newton’s formula.
Stop when close to a root.
Color each point by which root it reached (different basins).
Key Code Differences
Aspect	Mandelbrot	Newton
Iteration formula	
z
=
z
2
+
c
z=z 
2
 +c	
z
=
z
−
f
(
z
)
/
f
′
(
z
)
z=z−f(z)/f 
′
 (z)
Input parameter	Complex constant
c
c	Initial guess 
z
0
z 
0
​	
 
Convergence test	(	z
Coloring	Escape time (speed of divergence)	Basin of attraction (which root)
Visualization	Boundary of bounded/unbounded	Boundary between root basins
👉 So, Mandelbrot is divergence coloring, while Newton is root-attraction coloring.
Would you like me to also show you the Julia set code (close cousin of Mandelbrot) so you can compare all three types side by side?

If I just want to present it in the style of a rainbow chart?
ChatGPT said: 
Understood 👍 If you only want the rainbow style, then you can keep the "color_map_1" I wrote earlier separately, remove the loop, and restore it to your original similar logic. 
Here is the concise version of the code for you: 
import torch
import numpy as np
import matplotlib.pyplot as plt

# Device configuration
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# Create a grid in the complex plane
Y, X = np.mgrid[-1.3:1.3:0.005, -2:1:0.005] 
eps = 1e-6

# Load into PyTorch tensors
x = torch.tensor(X, dtype=torch.float32)
y = torch.tensor(Y, dtype=torch.float32)
z = torch.complex(x, y)  # constant c
zs = z.clone()           # z_0 = c
ns = torch.zeros_like(z) # divergence counter

# Transfer to GPU if available
z, zs, ns = z.to(device), zs.to(device), ns.to(device)
ns = torch.zeros(z.shape, dtype=torch.int32, device=device)
converged_root = torch.full(z.shape, -1, dtype=torch.int32, device=device)

# Roots of z^3 = 1
roots = torch.tensor([
1+0j,
-0.5 + 0.8660254j,
-0.5 - 0.8660254j ], dtype=torch.complex64, device=device)

# Newton iterations
for i in range(200):
zs = zs - (zs**3 - 1) / (3 * zs**2 + eps)
for j, r in enumerate(roots):
mask = (converged_root == -1) & (torch.abs(zs - r) < 1e-3)
converged_root[mask] = j
ns[mask] = i

# Rainbow Style Mapping def color_map_rainbow(a):
a_cyclic = (6.28 * a / 20.0).reshape(list(a.shape) + [1]) img = np.concatenate([
10 + 20 * np.cos(a_cyclic),
30 + 50 * np.sin(a_cyclic),
155 - 80 * np.cos(a_cyclic)
], 2) img[a == a.max()] = 0
return np.uint8(np.clip(img, 0, 255))

# Generate Image ns_cpu = ns.cpu().numpy()
img = color_map_rainbow(ns_cpu)

plt.figure(figsize=(16, 10))
plt.imshow(img)
plt.axis("off")
plt.tight_layout(pad=0)
plt.savefig("Newton_fractal_Rainbow.png", dpi=300, bbox_inches="tight")
plt.show()

?? Summary of Changes 
Only one function "color_map_rainbow()" is retained, corresponding to the desired rainbow style. 
Removed other colorization functions and loops. 
Save the image file name as "Newton_fractal_Rainbow.png". 
Finally, plt.show() was added to make it convenient for you to directly view the results. 
Would you like me to modify it so that it saves both the rainbow style and the rainbow gradient (in two versions, brighter and darker)? This way, it will highlight the main style while also showing the variations.
